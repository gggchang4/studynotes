# 基础理论
# 二分查找
二分查找算法最主要是要注意边界条件
```C++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int length = nums.size();
        int left = 0, right = length -1;
        while(left <= right) {
            int mid = (left + right)/2;
            if(nums[mid] == target) {
                return mid;
            }
            else if(nums[mid] < target) {
                left = mid + 1;
            }
            else {
                right = mid - 1;
            }
        }
        return -1;
    }
};
```
# 移除元素
## 1.暴力解法
双重循环，一层循环遍历，一层循环更新元素
```C++
//brute force solution
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int size = nums.size();
        for (int i = 0; i < size; i++) {
            if (nums[i] == val) { // 发现需要移除的元素，就将数组集体向前移动一位
                for (int j = i + 1; j < size; j++) {
                    nums[j - 1] = nums[j];
                }
                i--; // 因为下标i以后的数值都向前移动了一位，所以i也向前移动一位
                size--; // 此时数组的大小-1
            }
        }
        return size;
    }
};
```
## 2.快慢指针法
```C++
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int slowIndex = 0;
        for (int fastIndex = 0; fastIndex < nums.size(); fastIndex++) {
            if (val != nums[fastIndex]) {
                nums[slowIndex++] = nums[fastIndex];
            }
        }
        return slowIndex;
    }
};
```
# 有序数组的平方
## 1.暴力解法
```C++
//brute force solution,square first,then sort again
class Solution1 {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        int size = nums.size();
        //第一次遍历先把每个元素平方一遍
        for(int i = 0; i <= size-1; i++) {
            nums[i] = nums[i]*nums[i];
        }
        //然后排序，这里选择冒泡排序
        for(int i = 0; i < size-1; i++) {
            for(int j = 0; j < size-i-1; j++) {
                if(nums[j] > nums[j+1]) {
                    int temp = nums[j+1];
                    nums[j+1] = nums[j];
                    nums[j] = temp;
                }
            }
        }
        //或者使用快排
        //sort(nums.begin(),nums.end());
        return nums;
    }
};
```
## 2.双指针法
双指针，两头往中间遍历，每次对比两边绝对值大小，挑出大的放result数组(从右往左)
```C++
class Solution2 {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        int size = nums.size();
        vector<int> result(size);
        int front = 0, end = size - 1;
        for(int i = size-1; i >= 0; i--) {
            if(nums[front]*nums[front] >= nums[end]*nums[end]) {
                result[i] = nums[front]*nums[front];
                front++;
            }
            else {
                result[i] = nums[end]*nums[end];
                end--;
            }
        }
        return result;
    }
};
```
# 长度最小的子数组
子数组必须是原数组的连续元素片段
## 1.暴力解法
利用两层循环遍历完所有的数组，两层循环的循环变量，一个是滑动窗口的起始位置，一个为滑动窗口的终止位置
时间复杂度$O(n^2)$
```C++
class Solution2 {
public:
    int minSubArrayLen(int s, vector<int>& nums) {
        int result = INT32_MAX; // 最终的结果
        int sum = 0; // 子序列的数值之和
        int subLength = 0; // 子序列的长度
        for (int i = 0; i < nums.size(); i++) { // 设置子序列起点为i
            sum = 0;
            for (int j = i; j < nums.size(); j++) { // 设置子序列终止位置为j
                sum += nums[j];
                if (sum >= s) { // 一旦发现子序列和超过了s，更新result
                    subLength = j - i + 1; // 取子序列的长度
                    result = result < subLength ? result : subLength;
                    break; // 因为我们是找符合条件最短的子序列，所以一旦符合条件就break
                }
            }
        }
        // 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列
        return result == INT32_MAX ? 0 : result;
    }
};
```
## 2.滑动窗口法
滑动窗口法是一个经典的方法，利用两个指针作为窗口的起始位置和结束位置，通过动态变化两个指针的位置，完成相应的窗口内的操作，降低时间和空间复杂度
一个for循环完成，for循环的循环变量作为结束位置，动态变化开始位置的指针
时间复杂度$O(n)$
不要以为for里放一个while就以为是O(n^2)啊， 主要是看每一个元素被操作的次数，每个元素在滑动窗后进来操作一次，出去操作一次，每个元素都是被操作两次，所以时间复杂度是 2 × n 也就是O(n
```C++
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int result = INT32_MAX;
        int sum = 0; // 滑动窗口数值之和
        int i = 0; // 滑动窗口起始位置
        int subLength = 0; // 滑动窗口的长度
        //外层循环变量是滑动窗口的末尾位置指针
        for (int j = 0; j < nums.size(); j++) {
            sum += nums[j];
            // 注意这里使用while，每次更新 i（起始位置），并不断比较子序列是否符合条件
            while (sum >= target) {
                subLength = (j - i + 1); // 取子序列的长度
                result = result < subLength ? result : subLength;
                sum -= nums[i++]; // 这里体现出滑动窗口的精髓之处，不断变更i（子序列的起始位置）
            }
        }
        // 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列
        return result == INT32_MAX ? 0 : result;
    }
};
```

# 螺旋矩阵
螺旋矩阵本质就是模拟在矩阵中顺时针遍历的过程，怎么模拟这个过程，变量该如何设置和控制是需要好好思考的
```C++
class Solution {
public:
    vector<vector<int>> generateMatrix(int n) {
        vector<vector<int>> res(n, vector<int>(n, 0)); // 使用vector定义一个二维数组
        int startx = 0, starty = 0; // 定义每循环一个圈的起始位置
        int loop = n / 2; // 每个圈循环几次，例如n为奇数3，那么loop = 1 只是循环一圈，矩阵中间的值需要单独处理
        int mid = n / 2; // 矩阵中间的位置，例如：n为3， 中间的位置就是(1，1)，n为5，中间位置为(2, 2)
        int count = 1; // 用来给矩阵中每一个空格赋值
        int offset = 1; // 需要控制每一条边遍历的长度，每次循环右边界收缩一位
        int i,j;
        while (loop --) {
            i = startx;
            j = starty;

            // 下面开始的四个for就是模拟转了一圈
            // 模拟填充上行从左到右(左闭右开)
            for (j; j < n - offset; j++) {
                res[i][j] = count++;
            }
            // 模拟填充右列从上到下(左闭右开)
            for (i; i < n - offset; i++) {
                res[i][j] = count++;
            }
            // 模拟填充下行从右到左(左闭右开)
            for (; j > starty; j--) {
                res[i][j] = count++;
            }
            // 模拟填充左列从下到上(左闭右开)
            for (; i > startx; i--) {
                res[i][j] = count++;
            }

            // 第二圈开始的时候，起始位置要各自加1， 例如：第一圈起始位置是(0, 0)，第二圈起始位置是(1, 1)
            startx++;
            starty++;

            // offset 控制每一圈里每一条边遍历的长度
            offset += 1;
        }

        // 如果n为奇数的话，需要单独给矩阵最中间的位置赋值
        if (n % 2) {
            res[mid][mid] = count;
        }
        return res;
    }
};
```

# 区间和
## 暴力解法
```C++
#include <iostream>
#include <vector>
using namespace std;
int main() {
    int n, a, b;
    cin >> n;
    vector<int> vec(n);
    for (int i = 0; i < n; i++) cin >> vec[i];
    while (cin >> a >> b) {
        int sum = 0;
        // 累加区间 a 到 b 的和
        for (int i = a; i <= b; i++) sum += vec[i];
        cout << sum << endl;
    }
} 
```
## 前缀和
前缀和就是利用和的数组相减得到区间和，时间复杂度会比暴力解法小一些
- C++ 代码 面对大量数据 读取 输出操作，最好用scanf 和 printf，耗时会小很多
```C++
#include <iostream>
#include <vector>
using namespace std;
int main() {
    int n, a, b;
    cin >> n;
    vector<int> vec(n);
    vector<int> p(n);
    int presum = 0;
    for (int i = 0; i < n; i++) {
        cin >> vec[i];
        presum += vec[i];
        p[i] = presum;
    }

    while (cin >> a >> b) {
        int sum;
        if (a == 0) sum = p[b];
        else sum = p[b] - p[a - 1];
        cout << sum << endl;
    }
}
```

# 开发商购买土地问题
求一个矩阵横向或纵向切割后两个半部分的差值的最小值
主要的思想也是==前缀和==
```C++
int main_1() {
    int n, m;
    cin >> n >> m;
    vector<vector<int>> land(n, vector<int>(m));
    vector<int> rowSum(n, 0), colSum(m, 0);
    // 读入数据并计算行、列总和
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            cin >> land[i][j];
            rowSum[i] += land[i][j];
            colSum[j] += land[i][j];
        }
    }
    // 计算总和
    int total = 0;
    for (int i = 0; i < n; i++) total += rowSum[i];
    // 计算行前缀和
    for (int i = 1; i < n; i++) rowSum[i] += rowSum[i - 1];
    // 计算列前缀和
    for (int j = 1; j < m; j++) colSum[j] += colSum[j - 1];

    int minDiff = INT_MAX;

    // 横向切割（上、下两部分）
    for (int i = 0; i < n - 1; i++) {
        int upper = rowSum[i];
        int lower = total - upper;
        minDiff = min(minDiff, abs(upper - lower));
    }
  
    // 纵向切割（左、右两部分）
    for (int j = 0; j < m - 1; j++) {
        int left = colSum[j];
        int right = total - left;
        minDiff = min(minDiff, abs(left - right));
    }
    cout << minDiff << endl;
    return 0;
}
```