# 哈希表简介
## 定义
哈希表是一种根据键（Key）直接计算存储位置的数据结构。它通过哈希函数将 Key 映射到数组下标，从而实现平均 O(1) 的查找、插入和删除操作
## 核心组成
### 哈希函数 Hash Function
将 Key 映射为数组下标的函数
- 计算速度快
- 相同的key必须得到相同的哈希值
- 不同key尽可能减少冲突
![[Pasted image 20251117203407.png|400]]
### 哈希冲突 Hash Collision
不同 Key 经过哈希函数后可能得到相同的下标，这种情况称为哈希冲突

## 冲突解决方法
### 链地址法 Separate Chaining （拉链法）

每个数组元素保存一个链表或 vector，用来存储所有哈希值相同的键值对
![[Pasted image 20251117203446.png|400]]
特点：
- 实现简单
- 扩容前性能较稳定
- 最坏情况下查找退化为链表查找 O(n)
### 开放地址法 Open Addressing

发生冲突后，从当前位置继续向后寻找空槽来存放数据
- 要保证tablesize>datasize
常见策略：
- 线性探测（Linear Probing）
- 二次探测（Quadratic Probing）
- 双重哈希（Double Hashing）
特点：
- 不使用额外链表，节省指针开销
- 删除操作较复杂
- 装载因子过高时性能下降明显

## 装载因子 Load Factor
### 定义
```ini
load_factor = 元素数量 / 桶（数组）大小

```

意义：
- 描述哈希表的“拥挤”程度
- 装载因子越高，冲突越多，性能下降
- 当 load factor 超过阈值时会触发扩容（rehash）

C++ STL 中 `unordered_map` 默认最大装载因子为 1.0。

## 常见应用场景
- 字典、键值对存储（如 `unordered_map`）
- 去重集合（如 `unordered_set`）
- 统计词频、字符频次
- 实现 LRU 缓存
- 两数之和问题
- 图的邻接表

## 常见的Hash结构
想使用哈希表解决问题时一般选择以下三种数据结构
- 数组
- set
- map