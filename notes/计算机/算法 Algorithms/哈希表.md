# 哈希表简介
## 定义
哈希表是一种根据键（Key）直接计算存储位置的数据结构。它通过哈希函数将 Key 映射到数组下标，从而实现平均 O(1) 的查找、插入和删除操作
## 核心组成
### 哈希函数 Hash Function
将 Key 映射为数组下标的函数
- 计算速度快
- 相同的key必须得到相同的哈希值
- 不同key尽可能减少冲突
![[Pasted image 20251117203407.png|400]]
### 哈希冲突 Hash Collision
不同 Key 经过哈希函数后可能得到相同的下标，这种情况称为哈希冲突

## 冲突解决方法
### 链地址法 Separate Chaining （拉链法）

每个数组元素保存一个链表或 vector，用来存储所有哈希值相同的键值对
![[Pasted image 20251117203446.png|400]]
特点：
- 实现简单
- 扩容前性能较稳定
- 最坏情况下查找退化为链表查找 O(n)
### 开放地址法 Open Addressing

发生冲突后，从当前位置继续向后寻找空槽来存放数据
- 要保证tablesize>datasize
常见策略：
- 线性探测（Linear Probing）
- 二次探测（Quadratic Probing）
- 双重哈希（Double Hashing）
特点：
- 不使用额外链表，节省指针开销
- 删除操作较复杂
- 装载因子过高时性能下降明显

## 装载因子 Load Factor
### 定义
```ini
load_factor = 元素数量 / 桶（数组）大小

```

意义：
- 描述哈希表的“拥挤”程度
- 装载因子越高，冲突越多，性能下降
- 当 load factor 超过阈值时会触发扩容（rehash）

C++ STL 中 `unordered_map` 默认最大装载因子为 1.0。

## 常见应用场景
- 字典、键值对存储（如 `unordered_map`）
- 去重集合（如 `unordered_set`）
- 统计词频、字符频次
- 实现 LRU 缓存
- 两数之和问题
- 图的邻接表

## 常见的Hash结构
想使用哈希表解决问题时一般选择以下三种数据结构
- 数组
- set
- map
在C++中，set和map提供了以下几种数据结构可以作为哈希表使用

| 集合                 | 底层实现 | 是否有序  | 数值是否可以重复 | 能否修改数值  | 查询效率    | 增删效率    |
| ------------------ | ---- | ----- | -------- | ------- | ------- | ------- |
| std::set           | 红黑树  | 有序    | 否        | 否       | O(logn) | O(logn) |
| std::multiset      | 红黑树  | 有序    | 是        | 否       | O(logn) | O(logn) |
| std::unordered_set | 哈希表  | 无序    | 否        | 否       | O(1)    | O(1)    |
| std::map           | 红黑树  | key有序 | key不可重复  | key不可修改 | O(logn) | O(logn) |
| std::multimap      | 红黑树  | key有序 | key可重复   | key不可修改 | O(logn) | O(logn) |
| std::unordered_map | 哈希表  | key无序 | key不可重复  | key不可修改 | O(1)    | O(1)    |
当我们要使用集合来解决哈希问题的时候，优先使用==unordered_set==，因为它的查询和增删效率是最优的，如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset

# 有效的字母异位词
判断两个字符串是不是有效的字母异位词，只需要维护一个数组作为哈希表，遍历第一个字符串记录每个字符出现的次数，再遍历第二个字符串，如果这个字符串的字符数目和第一个不同，则不是。。。
```C++
class Solution {
public:
    bool isAnagram(string s, string t) {
        int record[26] = {0};
        for (int i = 0; i < s.size(); i++) {
            // 并不需要记住字符a的ASCII，只要求出一个相对数值就可以了
            record[s[i] - 'a']++;
        }
        for (int i = 0; i < t.size(); i++) {
            record[t[i] - 'a']--;
        }
        for (int i = 0; i < 26; i++) {
            if (record[i] != 0) {
                // record数组如果有的元素不为零0，说明字符串s和t 一定是谁多了字符或者谁少了字符。
                return false;
            }
        }
        // record数组所有元素都为零0，说明字符串s和t是字母异位词
        return true;
    }
};
```
# 两个数组的交集
本题暴力解法双重循环找出交集，对于重复元素的处理比较麻烦
所以使用容器unordered_set最合适，主要注意容器的用法
```C++
class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        unordered_set<int> result_set; // 存放结果，之所以用set是为了给结果集去重
        unordered_set<int> nums_set(nums1.begin(), nums1.end());
        for (int num : nums2) {
            // 发现nums2的元素 在nums_set里又出现过
            if (nums_set.find(num) != nums_set.end()) {
                result_set.insert(num);
            }
        }
        return vector<int>(result_set.begin(), result_set.end());
    }
};
```
# 快乐数
快乐数就是各个位上的数字加起来求和循环，最终能等于1就是快乐数，否则不是
本题主要注意用哈希表判断是否是无限循环，循环则代表不是快乐数，还要注意各位求和的写法
```C++
class Solution {
public:
    int bitsum(int n) {  
        int sum = 0;
        while (n > 0) {
            int digit = n % 10;  
            sum += digit * digit;
            n /= 10;  
        }
        return sum;
    }
    bool isHappy(int n) {
        if (n == 1) return true;
        unordered_set<int> seen;
        while (n != 1) {
            if (seen.count(n)) {
                return false;  
            }
            seen.insert(n);
            n = bitsum(n);
        }
        return true;
    }
};
```
```C++
class Solution {
public:
    // 取数值各个位上的单数之和
    int getSum(int n) {
        int sum = 0;
        while (n) {
            sum += (n % 10) * (n % 10);
            n /= 10;
        }
        return sum;
    }
    bool isHappy(int n) {
        unordered_set<int> set;
        while(1) {
            int sum = getSum(n);
            if (sum == 1) {
                return true;
            }
            // 如果这个sum曾经出现过，说明已经陷入了无限循环了，立刻return false
            if (set.find(sum) != set.end()) {
                return false;
            } else {
                set.insert(sum);
            }
            n = sum;
        }
    }
};
```
# 两数之和
题目：
给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** _`target`_  的那 **两个** 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。

你可以按任意顺序返回答案。

## brute force
```C++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        vector<int> ans;
        for(int i=0; i<nums.size()-1; ++i) {
            for(int j=i+1; j<nums.size(); ++j) {
                if(nums[i]+nums[j]==target) {
                    ans.push_back(i);
                    ans.push_back(j);
                }
            }
        }
        return ans;
    }
};
```
## hash
```C++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int,int> hashTable;
        for(int i=0; i<nums.size(); ++i) {
            auto it = hashTable.find(target - nums[i]);
            if(it != hashTable.end()) {
                return {it->second,i};
            }
            hashTable[nums[i]] = i;
        }
    }
};
```
