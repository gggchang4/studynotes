---
date: "2025"
tags:
  - 操作系统
---
# 第一章 导论

## 操作系统类型

1. 批处理操作系统
	- 批处理技术是指计算机系统对一批作业自动进行处理的一种技术
2. 分时操作系统
	- n把处理机的运行时间分成很短的时间片，按时间片轮流把处理机分配给各联机作业使用。
	- n若某个作业在分配给它的时间片内不能完成其计算，则该作业暂停运行，把处理机让给另一个作业使用，等待下一轮时再继续其运行。
3. 实时操作系统
## 作业
- 作业是用户在一次解题或一个事务处理过程中要求计算机系统所做工作的集合，包括用户程序、所需的数据及命令等

## 操作系统内核 

- 在操作系统设计中，往往把一些与硬件紧密相关的模块、运行频率较高的模块及公用的一些基本操作安排在靠近硬件的软件层次中，使它们常驻内存，以提高操作系统的运行效率，通常把这部分软件称为操作系统内核
- 内核主要包括：
	- 中断
	- 时钟管理
	- 进程管理
	- 存储器管理
	- 设备管理
## 原语
- n原语是由若干条机器指令构成的，用以完成特定功能的一段程序，这段程序在执行期间不可分割。
---
# 第二章 操作系统结构 (Operating-System Structures)
## 本章目标
1. ​**操作系统提供的服务**  
   - 用户接口（CLI/GUI）、程序执行、I/O操作、文件系统操纵、进程通信、错误检测、资源分配、统计、保护与安全

2. ​**操作系统结构方法**  
   - 讨论不同组织方式（如分层结构、微内核等）

3. ​**系统调用的作用**  
   - 说明如何通过系统调用提供OS服务
## 2.1 操作系统服务 (Operating-System Services)
### 核心服务
- ​**用户接口**  
  - 命令行接口（CLI）、批处理接口、图形用户接口（GUI）
- ​**程序执行**  
  - 加载程序到内存并运行
- ​**I/O操作**  
  - 提供I/O操作支持（如设备驱动）
- ​**文件系统操纵**  
  - 文件读写、创建、删除
- ​**通信**  
  - 进程间信息交换（IPC）
- ​**错误检测**  
  - 硬件/软件错误检测与处理
- ​**资源分配**  
  - 多任务资源分配（CPU、内存等）
- ​**统计与安全**  
  - 记录资源使用情况，控制访问权限
## 2.2 用户接口 (User Operating-System Interface)
### 1. 命令解释程序 (Command Interpreter)
- ​**功能**：获取并执行用户命令  
- ​**类型**：
  - ​**联机控制**：实时交互（如终端命令）
  - ​**脱机控制**：通过作业控制说明书提交任务
### 2. 图形用户接口 (GUI)
- ​**特点**：基于窗口和菜单的交互，减少记忆负担  
- ​**优势**：直观易用（如Windows、macOS界面）
## 2.3 系统调用 (System Calls)
### 作用
- ​**桥梁**：用户程序与操作系统内核的接口  
- ​**参数传递方式**：
  1. 寄存器传递  
  2. 内存表传递（表地址存寄存器）  
  3. 栈传递（程序压栈，OS弹栈）
### 系统调用类型
| ​**类别**       | ​**示例**                          |
|----------------|-----------------------------------|
| 进程控制       | 创建/终止进程、等待事件           |
| 文件管理       | 创建/删除文件、读写操作           |
| 设备管理       | 请求/释放设备、I/O操作            |
| 信息维护       | 获取/设置时间、系统状态查询       |
| 通信           | 进程间消息发送/接收               |

### 与过程调用的区别
| ​**对比项**     | ​**系统调用**                     | ​**过程调用**               |
|---------------|----------------------------------|----------------------------|
| 运行状态       | 核心态（Kernel Mode）            | 用户态（User Mode）        |
| 进入方式       | 通过中断机制切换状态             | 直接调用，不切换状态       |

## 2.4 系统服务 (System Services)
- ​**目的**：为程序开发和执行提供便利环境  
- ​**常见服务**：
  - 程序加载与执行  
  - 文件系统工具（如备份、磁盘格式化）  
  - 状态监控与调试工具  
---
# 第3章 进程（Chapter 3 Processes）
**目标**  
1. **进程的组成**：介绍进程的组成部分（代码段、数据段、PCB等）。  
2. **进程的创建与终止**：描述操作系统如何创建和终止进程。  
## 3.1 进程的概念（Process Concept）
### 1. 进程的定义
• **进程**是程序的一次执行实例，是资源分配和调度的基本单位。 
• 进程是可以和别的计算并行执行的计算
• 进程是程序在一个数据集合上运行的过程，是系统进行资源分配和调度的一个独立单位
• 进程是一个具有一定功能的程序关于某个数据集合的一次运行活动
• **作业（Job）与进程在本书中可互换使用。  
### 2. 前趋图（Precedence Graph）
• **定义**：有向无环图（DAG），描述程序/进程执行的先后顺序。  
• **结点**：表示语句、程序段或进程。  
• **边（→）**：表示前趋关系（Pi→Pj：Pi必须在Pj之前完成）。  
  • **初始结点**：无前趋的结点。  
  • **终止结点**：无后继的结点。  
  前趋图例
  ![[QQ_1744108643734.png|300]]
### 3. 程序的执行方式
• **顺序执行**：  
  • **特征**：顺序性、封闭性（不受外界干扰）、可再现性（相同输入必得相同结果）。  
• **并发执行**：  
  • **特征**：间断性、失去封闭性（共享资源导致相互影响）、不可再现性（执行结果依赖时序）。  
  • **并发条件（Bernstein条件）**：  
    ◦ 两个程序段的读集（R）和写集（W）无冲突：  
      ◦ `R(Si) ∩ W(Sj) = ∅`  
      ◦ `W(Si) ∩ R(Sj) = ∅`  
      ◦ `W(Si) ∩ W(Sj) = ∅`  
   •**并发语句的描述方式**  ：
```
   cobegin
	   S1;S2; ...Sn;
   coend
   //对应的前趋图如右，其中S0和Sn+1分别是cobegin和coend语句前后的两条语句
```
![[Pasted image 20250408184654.png|200]]
### 3.1.1 进程
• 进程是执行中的程序（非正式的说法）
• **一个进程包括
1. 代码段 text section
2. 程序计数器和处理机寄存器内容
3. 栈 stack
4. 数据段 data section
##### 内存中的进程
![[Pasted image 20250408190019.png|200]]
##### memory layout of a c program
![[Pasted image 20250408121021.png]]
### 4. 进程的特征
• **动态性**：生命周期（创建→执行→终止）。  
• **并发性**：多个进程同时存在于内存。  
• **独立性**：资源分配和调度的基本单位。  
• **异步性**：进程以不可预测的速度推进。  
• **结构性**：由程序段、数据段和PCB组成。  
### 5. 进程与程序的区别
• **动态 vs 静态**：进程是执行中的程序，程序是指令集合。  
• **临时 vs 永久**：进程是暂时的，程序可永久存储。  
• **组成**：进程包含PCB，程序仅包含代码和数据。  
•  进程可以创建新进程，程序不能形成新程序

---
### 3.1.2 进程状态（Process State）
#### 基本状态
1. **新建（New）**：进程刚创建，未进入就绪队列。  
2. **就绪（Ready）**：已获资源，等待CPU分配。  
3. **运行（Running）**：正在CPU上执行。  
4. **等待/阻塞（Waiting）**：因事件（如I/O）暂停执行。  
5. **终止（Terminated）**：进程结束，资源被回收。  
##### 进程状态图
![[Pasted image 20250408190852.png]]
状态转换的有关说明
1. 大多数状态不可逆，如等待不能转为运行
2. 状态转换大多为被动进行，但运行->等待是主动的
3. 一个进程在一个时刻只能处于上述状态之一
#### **挂起状态**（Suspended State）
• **原因**：系统故障、检查中间结果、资源不足、内存不足等。  
• **状态转换**：  
  • **挂起**：活动→静止（如就绪→挂起就绪）。  
  • **激活**：静止→活动（如挂起就绪→就绪）。
##### 有挂起状态的进程状态转换图
![[eebb614f90e47e7258225a1ce3032581.png]]
#### **因果变迁**
如果一个状态变化A的发生，会引起另一个状态变化B的发生，则称A,B之前是因果变迁
## 3.1.3 进程控制块（PCB）

• 定义：PCB是描述和管理进程的数据结构。它是进程实体的一部分，操作系统通过PCB感知进程的存在，*PCB是进程存在的唯一标志*

• 作用：操作系统感知和管理进程的核心数据结构。  

• 不同操作系统中PCB的结构不同，但通常包括以下内容
1. **进程标识符**：惟一标识进程的一个标识符或整数
2. **进程当前状态**：说明进程当前所处状态
3. **进程队列指针**：用于记录PCB队列中下一个PCB的地址
4. **程序和数据地址**：进程的程序和数据在内存或外存中的存放地址
5. **进程优先级**：反映进程获得CPU的优先级别
6. **CPU现场保护区**：CPU现场信息的存放区域，包括：通用寄存器、程序计数器、程序状态字等
7. **通信信息**：进程与其他进程所发生的信息交换
8. **家族关系**：指明本进程与家族的关系，如父子进程标识
9. **资源清单**：列出进程所需资源及当前已分配资源
##### 进程控制块
![[QQ_1744111288365.png|400]]
![[Pasted image 20250408192211.png|150]]

## 3.2 进程调度（Process Scheduling）
### 3.2.1 调度队列
1. **作业队列**：系统中所有进程的集合。  
2. **就绪队列**：等待CPU的进程（链表实现）。  
3. **设备队列**：等待I/O设备的进程。  
##### 就绪队列和各种I/O设备队列
![[Pasted image 20250408194333.png]]
##### 表示进程调度的队列图
![[Pasted image 20250408194403.png]]

### 3.2.2 CPU调度
### 调度类型
• **长程调度（作业调度）**：控制多道程序度（选择可以进入就绪队列的进程）。  
• **短程调度（CPU调度）**：选择可下一个执行并分配CPU的进程（高频操作）。  
   %% 两者的主要差别是执行频率 %%
• **中程调度**：部分系统引入，管理内存中的进程挂起/激活。  
##### 中程调度
![[Pasted image 20250408194950.png]]

进程可以分为
• **I/O型进程**：花费I/O 时间多于计算
• **CPU 型进程**：花费更多时间用于计算
### 上下文切换（Context Switch）

• 定义：将CPU切换到另一个进程需要保存当前进程的状态并恢复另一个进程的状态，这一任务称为上下文切换

• **开销**：保存当前进程状态，恢复目标进程状态（CPU无实际工作），上下文切换的时间开销较重
##### 进程间的CPU切换
![[Pasted image 20250408195212.png]]

## 3.3 进程操作（Operating on Processes）

进程操作一般由操作系统内核原语来实现
### 1. ==进程创建==（Process Creation）
• **方式**：  
  • **资源共享**：
  - 父进程子进程共享所有的资源
  - 子进程共享父进程资源的子集
  - 父进程和子进程无资源共享
  • **执行方式**：
  - 父进程和子进程并发执行
  - 父进程等待，直到子进程终止
  • **地址空间**：
  - 子进程是父进程的复制品
  - 子进程装入一个新程序
• **原因**：
- 用户登录：用户登录后，若合法则为用户创建一个进程
- 作业调度：为调度到的作业分配资源并创建进程
- OS服务：创建服务进程
- 应用需要：应用程序根据需要创建子进程
##### unix系统中的进程树
![[Pasted image 20250409102206.png]]
##### 进程创建
![[Pasted image 20250409102233.png]]
**创建原语**：
进程创建原语的功能是创建一个新进程，其主要操作过程如下
1. 向系统申请一个空闲PCB
2. 为新进程分配资源。如分配内存空间
3. 初始化新进程的PCB。在其PCB中填入进程名、家族信息、程序和数据地址、进程优先级、资源清单及进程状态等
4. 将新进程的PCB插入就绪队列
     
### 2.  ==进程终止==（Process Termination）
  - 当进程执行完最后一条语句并使用系统调用exit()请求操作系统删除自身时，进程终止
- 这时进程将状态值返回给父进程，所有进程资源由操作系统回收
- 进程终止也叫进程撤销

• **原因**：
- 正常结束
- 异常结束：超时、内存不足、地址越界、算术错、I/O故障、非法指令等
- 外界干预：包括操作员或系统干预，父进程请求

• 父进程终止子进程的原因：
- 子进程超量使用分配的资源
- 赋予子进程的任务不再需要
- 父进程退出 Parent is exiting

• **级联终止**：父进程终止导致所有子进程终止。  

• **撤销原语**：
撤销原语采用的两种策略
- 撤消指定标识符的进程
- 撤消指定进程及其所有子孙进程
主要操作过程
1. 从系统的PCB表中找到被撤消进程的PCB
2. 检查被撤消进程的状态是否为执行状态，若是则立即停止该进程的执行，设置重新调度标志
3. 检查被撤消进程是否有子孙进程，若有子孙进程还应撤消该进程的子孙进程
4. 回收该进程占有的全部资源并回收其PCB 
### 3. 阻塞与唤醒（Block/Wakeup）
• **阻塞**：进程主动等待事件（如I/O完成）。  
• **唤醒**：由其他进程（如I/O完成者）触发。  

### **阻塞原语和撤销原语**

阻塞原语的主要功能是将进程由执行状态转为阻塞状态。其主要操作过程如下：
- 停止当前进程的执行
- 保存该进程的CPU现场信息
- 将进程状态改为阻塞，并插入到相应事件的等待队列中
- 转进程调度程序，从就绪队列中选择一个新的进程投入运行

唤醒原语的主要功能是将进程唤醒，其主要操作过程如下：
- 将被唤醒进程从相应的等待队列中移出
- 将进程状态改为就绪，并将该进程插入就绪队列
- 转进程调度或返回

阻塞与唤醒的关系：
- 一个进程由执行状态转变为阻塞状态，是这个进程自己调用阻塞原语去完成的
- 进程由阻塞状态转变为就绪状态，是另一个发现者进程调用唤醒原语实现的
- 一般发现者进程与被唤醒进程是合作的并发进程

### **进程的挂起与激活**
• 挂起原语和激活原语的实现方式
- 把发出挂起原语的进程自身挂起
- 挂起具有指定标识符的进程
- 把某进程及其子孙进程挂起
- 激活一个具有指定标识名的进程
- 激活某进程及其子孙进程

### 4. 进程通信（IPC）
• **共享内存**：通过共享数据结构或存储区通信。  
• **消息传递**：直接（发送到接收队列）或间接（通过信箱）。  
• **管道（Pipe）**：基于共享文件的通信方式。  
## 3.5-3.6 IPC机制
### 生产者-消费者问题（Producer-Consumer）
• **缓冲区类型**：  
  • **无界缓冲**：生产者可无限生产。  
  • **有界缓冲**：缓冲区大小固定（需同步）。  
• **共享变量**：`in`（生产指针）、`out`（消费指针）。  
### 消息传递系统
• **操作**：`send(message)`、`receive(message)`。  
• **通信方式**：  
  • **直接**：明确指定接收方。  
  • **间接**：通过中间实体（如信箱）。  
## 关键总结
• **进程是动态实体**，由PCB唯一标识，通过状态转换实现并发。  
• **调度队列和上下文切换**是管理多进程的核心机制。  
• **进程通信**通过共享内存、消息传递或管道实现协作。  
• **同步问题**（如生产者-消费者）需结合IPC和同步机制（后续章节讨论）。

---
# 第4章 线程（Threads）总结
## 本章目标
1. **线程的基本组成**：理解线程的核心组件（如线程ID、程序计数器、寄存器、栈等），并对比线程与进程的异同。  
2. **线程的引入动机**：分析线程如何减少并发执行的时空开销，提升操作系统的并发性能。  
## 4.1 概述（Overview）
### 4.1.1 线程的动机（Motivation） 
1. **进程的两个属性**：  
   • **资源拥有单位**：进程拥有独立的虚拟地址空间、文件、I/O资源等。  
   • **调度单位**：传统进程是调度的基本单位（即“重型进程”）。  
2. **线程的引入原因**：  
   • 进程的创建、切换、撤销等操作涉及资源管理，开销较大。  
   • 将**调度单位（线程）**与**资源拥有单位（进程）**分离，提升效率。  
   • **线程（轻型进程）**：仅需少量资源（如寄存器、栈），共享进程的资源（代码、数据、文件等）。  
### 线程的定义与组成
• **核心组件**：线程ID、程序计数器（PC）、寄存器集、栈。  
• **共享资源**：同一进程内的线程共享代码段、数据段、操作系统资源（如打开的文件）。  
• **线程与进程的对比**：  
  • **线程**：轻量级，切换快，共享进程资源。  
  • **进程**：重量级，独立资源，切换开销大。  
### 线程的状态
• **生命周期**：创建、就绪、运行、阻塞、终止。  
• **特点**：  
  • 线程的阻塞不影响同一进程的其他线程。  
  • 进程的挂起或终止会影响其所有线程。  
## 4.1.2 线程的优点（Benefits） 
1. **响应能力强（Responsiveness）**：  
   • 即使部分线程阻塞（如I/O操作），其他线程仍可运行，保持程序响应。  
2. **资源共享（Resource Sharing）**：  
   • 线程共享进程资源（内存、文件），通信无需内核介入，效率高。  
3. **经济性（Economy）**：  
   • 创建、切换线程的开销远小于进程。  
4. **多处理器利用（Utilization of MP Architectures）**：  
   • 多线程可并行运行在多核CPU上，提升性能。  
**其他优势**：  
• 线程间通信无需内核干预（通过共享内存）。  
• 线程切换仅需保存少量寄存器状态，速度更快。  
## 4.3 多线程模型（Multithreading Models）
操作系统支持线程的三种方式：  
1. **内核线程（Kernel Threads）**：  
   • 由内核直接管理，线程的创建、调度、同步由内核完成。  
   • **优点**：一个线程阻塞不影响其他线程；适合多处理器环境。  
   • **缺点**：线程操作需内核介入，开销较大。  
2. **用户线程（User Threads）**：  
   • 在用户空间实现，内核无感知。  
   • **优点**：无需内核支持，切换速度快。  
   • **缺点**：一个线程阻塞会导致整个进程阻塞；无法利用多核CPU。  
3. **混合模型**：结合内核线程与用户线程的优势（如多对一、一对一、多对多模型）。 
## 关键总结 
• **线程的核心作用**：通过轻量级并发执行减少开销，提升系统吞吐量和响应速度。  
• **线程 vs 进程**：线程共享进程资源，切换更快；进程独立资源，适合隔离任务。  
• **多线程模型选择**：需权衡性能（内核线程）与灵活性（用户线程）。  
**应用场景**：  
• **高并发服务**（如Web服务器）使用多线程处理请求。  
• **多核CPU**：通过多线程并行计算加速任务。

---
# Chapter 5: CPU Scheduling 

一个作业从提交到完成通常要经历多级调度，且不同的操作系统所采用的调度层次不完全相同
## 1. 调度的层次

操作系统中的调度分为三级：

• **作业调度（高级调度）**  
- 功能：从外存后备队列中选择作业，分配资源（内存、I/O设备），创建进程
- 频率：低（几分钟一次）
- 目标：平衡系统负载，提高吞吐量

- 作业调度程序主要完成以下工作：
	 1. 记录进入系统的各个作业情况
	 2. 从后备作业中挑选一些作业投入执行
	 3. 为被选中的作业做好执行前的准备工作
	 4. 在作业运行结束或运行过程中因某种原因需要撤离时，作业调度程序还要完成作业的善后处理工作

• **中级调度（交换调度）**  
- 功能：管理内存与外存间的进程挂起和激活（如交换技术） 
- 频率：介于作业和进程调度之间 
- 目标：提高内存利用率

• **进程调度（低级调度）**  
- 功能：从就绪队列中选择进程分配CPU
- 频率：高（几十毫秒一次）
- 目标：最大化CPU利用率，减少响应时间

- 进程调度主要完成完成以下功能
	 1. 记录系统中所有进程的状态、优先数和资源情况
	 2. 选择获得处理机的进程
	 3. 实施处理机的分配及回收

- **引起进程调度的原因**
	1. 正在运行进程结束
	2. 运行进程因某种原因阻塞，如P操作、I/O等
	3. 抢占调度方式下，从系统调用或中断返回时，进程优先级高于当前运行进程
	4. 时间片用完
## 2. 作业与进程的状态转换
• **作业状态**：提交 → 后备 → 运行 → 完成
• **进程状态**：创建 → 就绪/阻塞 → 运行 → 退出  
• **关键转换**：作业调度将作业转为运行状态；进程调度分配CPU；中级调度处理挂起/激活
![[QQ_1745408632189.png]]

为管理作业，系统设置了作业控制块（JCB），系统通过JCB来感知作业的存在，JCB是作业存在的唯一标志
## 3. CPU调度基本概念

• **CPU-I/O区间周期**：进程执行由CPU执行（CPU Burst）和I/O等待（I/O Burst）交替组成。  
![[Pasted image 20250423203208.png|250]]

• CPU调度程序：
当CPU空闲时，操作系统必须从就绪队列中选择一个进程执行，选择进程由短程调度程序或CPU调度程序执行

• **调度触发时机**：  
	进程调度的两种方式：抢占方式，非抢占方式

- 非抢占式：进程终止或主动阻塞（如I/O请求）
	  eg.运行状态->等待状态；进程终止
	  非抢占方式中引起进程调度的因素有：进程结束、因某种原因而阻塞、执行同步原语等
	  非抢占式一旦将处理机分配给某进程后，便让该进程一直执行，直到该进程完成或发生某事件而进入阻塞状态
 
- 抢占式：更高优先级进程到达、时间片用完、中断返回时抢占
	  eg.运行状态->就绪状态；等待状态->就绪状态
	  抢占原则有：优先权，时间片
 
• **分派程序（Dispatcher）**：负责上下文切换、用户态跳转，引入分派延迟（调度开销）。
## 4. 调度准则
• **性能指标**：  
  • CPU利用率、吞吐量、周转时间（提交到完成）、等待时间（就绪队列等待）、响应时间（首次响应）。  
• **优化目标**：  
  • 最大化CPU利用率和吞吐量，最小化周转、等待和响应时间。  
• **周转时间与带权周转时间**：  
  • 带权周转时间 = 周转时间 / 实际运行时间，反映作业的“相对延迟”。
## 5. 调度算法
1. **先来先服务（FCFS）**  
   • 规则：按到达顺序分配CPU。  
   • 问题：护航效应（长作业导致短作业等待时间长）。  
   • 示例：平均周转时间可能较差（如长作业先到）。  
2. **最短作业优先（SJF）**  
   • 规则：选择预计CPU区间最短的进程。  
   • 非抢占式：进程运行时不可打断。  
   • 抢占式（最短剩余时间优先，SRTF）：新进程更短则抢占。  
   • 优点：最小化平均等待时间；缺点：需预知运行时间，可能导致长作业饥饿。  
3. **时间片轮转（RR）**  
   • 规则：固定时间片轮流分配CPU，超时则重新排队。  
   • 关键：时间片大小影响性能（太小增加切换开销，太大退化为FCFS）。  
   • 改进：虚拟轮转法（区分I/O型和CPU型进程）。  
4. **优先级调度**  
   • 规则：选择优先级最高的进程（静态或动态优先级）。  
   • 问题：低优先级进程饥饿 → 解决方案：老化（Aging），逐步提高等待进程的优先级。  
5. **高响应比优先（HRRN）**  
   • 规则：响应比 = 1 + 等待时间 / 运行时间，选择响应比最高者。  
   • 平衡FCFS和SJF，避免饥饿。  
6. **多级队列与多级反馈队列**  
   • **多级队列**：按进程类型（如前台/后台）划分固定优先级队列，每队列独立调度（如前台用RR，后台用FCFS）。  
   • **多级反馈队列**：  
     ◦ 动态调整：进程可在队列间移动（如CPU密集型降级，I/O密集型升级）。  
     ◦ 参数：队列数量、调度算法、升级/降级规则。  
## 6. 算法对比与适用场景
• **交互式系统**：RR、优先级调度、多级反馈队列（平衡响应时间）。  
• **批处理系统**：FCFS、SJF、HRRN（优化吞吐和周转时间）。  
• **实时系统**：需结合截止时间调度（本章未深入）。  
## 7. 关键问题与解决方案
• **饥饿**：通过老化或动态优先级调整解决。  
• **调度开销**：时间片大小需权衡（通常10-100ms）。  
• **公平性**：多级反馈队列兼顾长短作业、I/O与CPU型进程。  
## 8. 示例分析
• **FCFS vs SJF**：SJF显著降低平均周转时间（如从2.8到2.45）。  
• **RR时间片选择**：时间片=1时平均周转12.8，=4时降至12，但带权周转可能略差。  
• **HRRN**：综合等待与运行时间，例中平均周转9.6优于FCFS和SJF。  
## **总结**
CPU调度是操作系统的核心功能，需根据系统类型（批处理、交互式）和性能目标（吞吐量、响应时间）选择合适的算法。多级反馈队列因其灵活性和公平性成为通用系统的常见选择，而SJF和HRRN在特定场景下能优化周转时间。调度算法的设计需平衡效率、公平性和实现复杂度。

---
# Chapter6 同步工具  Chapter7 同步实例

## 1. 进程同步的核心问题
• **竞争条件（Race Condition）**：多个进程并发访问共享数据时，执行结果依赖于访问顺序，导致不确定性。
• **临界区问题（Critical-Section Problem）**：每个进程有一段访问共享资源的代码（临界区），需保证**互斥**（一次仅一个进程进入）、**前进**（无进程在临界区时允许进入）、**有限等待**（避免无限期等待）。
## 2. 同步解决方案
### **软件方法**
• **Peterson算法**：结合标志位（`flag[]`）和轮转变量（`turn`），解决双进程互斥问题，满足同步三原则。
  ```c
  do {
    flag[i] = true;
    turn = j;
    while (flag[j] && turn == j); // 忙等待
    // 临界区
    flag[i] = false;
    // 剩余区
  } while (true);
  ```
### **硬件方法**
• **原子指令**：
  • **Test-and-Set (TS)**：检查并设置锁变量，实现简单互斥。
    ```c
    boolean TS(boolean *lock) {
      boolean old = *lock;
      *lock = true;
      return old;
    }
    ```
  • **Swap**：交换两个变量的值，类似TS。
• **自旋锁（Spinlock）**：通过忙等待实现互斥，适用于短时间持有锁的场景。

### 信号量（Semaphore）
• **定义**：整型变量 + 等待队列，通过`wait()`（P操作）和`signal()`（V操作）原子操作控制。
  • **计数信号量**：资源数量（如缓冲区大小）。
  • **二进制信号量（互斥锁）**：0或1，用于互斥。
• **实现**：
  ```c
  wait(S) {
    S.value--;
    if (S.value < 0) { block(); } // 进程阻塞
  }
  signal(S) {
    S.value++;
    if (S.value <= 0) { wakeup(P); } // 唤醒等待进程
  }
  ```

## 3. 经典同步问题
##### **(1) 生产者-消费者问题（Bounded-Buffer Problem）**
• **同步关系**：
  • 缓冲区满时生产者等待（`empty`信号量）。
  • 缓冲区空时消费者等待（`full`信号量）。
  • 互斥访问缓冲区（`mutex`信号量）。
• **关键代码**：
  ```c
  // 生产者
  wait(empty); wait(mutex); // 生产并放入缓冲区
  signal(mutex); signal(full);
  // 消费者
  wait(full); wait(mutex); // 取出并消费
  signal(mutex); signal(empty);
  ```
• **注意**：P操作顺序不能颠倒，否则可能死锁（如先`wait(mutex)`再`wait(empty)`）。

### (2) 读者-写者问题（Readers-Writers Problem）
• **读者优先**：
  • 写者需等待所有读者完成。
  • 共享变量`readcount`记录读者数，`mutex`保护`readcount`，`writer`实现写互斥。
    ```c
    // 读者
    wait(mutex);
    if (readcount == 0) wait(writer); // 第一个读者阻塞写者
    readcount++;
    signal(mutex);
    // 读操作
    wait(mutex);
    readcount--;
    if (readcount == 0) signal(writer); // 最后一个读者唤醒写者
    signal(mutex);
    // 写者
    wait(writer); // 写操作; signal(writer);
    ```

### (3) 哲学家进餐问题（Dining-Philosophers Problem）
• **死锁风险**：所有哲学家同时拿起左筷子，导致循环等待。
• **解决方案**：
  1. 限制最多4个哲学家同时进餐。
  2. 仅当左右筷子均可用时才拿起（AND型信号量）。
  3. 奇数号先左后右，偶数号先右后左。

## 4. 高级同步机制
• **AND型信号量**：一次性分配所有所需资源，避免部分分配导致的死锁。
  ```c
  Swait(S1, S2, ..., Sn) {
    if (S1 >=1 && ... && Sn >=1) {
      for (i=1 to n) Si--;
    } else { block(); }
  }
  ```

## 5. 潜在问题
• **死锁（Deadlock）**：多个进程互相等待对方释放资源（如生产者-消费者中P操作顺序错误）。
• **饥饿（Starvation）**：某些进程长期得不到资源（如写者在读者优先策略中可能饥饿）。

## 6. 关键原则
1. **互斥**：临界区一次仅一个进程进入。
2. **前进**：无进程在临界区时，允许申请进入。
3. **有限等待**：避免无限期阻塞。
4. **让权等待**：无法进入临界区时释放CPU（如信号量阻塞而非忙等待）。
### **总结**
进程同步通过**互斥访问**和**条件协调**解决并发问题，核心工具包括**Peterson算法**、**硬件原子指令**、**信号量**。经典问题（生产者-消费者、读者-写者、哲学家进餐）展示了同步的实际应用，需注意**死锁**和**饥饿**的预防。信号量是通用解决方案，而高级机制（如AND型信号量）进一步优化资源分配。

---
# 第8章 死锁（Deadlocks）总结

## 1. 死锁的基本概念
• **定义**：一组进程因竞争资源或相互通信而陷入僵局，每个进程都在等待其他进程释放资源，导致所有进程都无法推进。
• **示例**：
  • 两列火车在十字路口互相等待对方先行。
  • 两个进程各占有一个磁带驱动器，同时需要对方的资源才能继续执行。

## 2. 死锁产生的必要条件
死锁发生的四个必要条件（必须全部满足）：
1. **互斥（Mutual Exclusion）**：资源一次只能被一个进程占用。
2. **占有并等待（Hold and Wait）**：进程持有至少一个资源，同时等待获取其他被占用的资源。
3. **非抢占（No Preemption）**：已分配给进程的资源不能被强制剥夺，只能由进程主动释放。
4. **循环等待（Circular Wait）**：存在一个进程等待环路，如 P0→P1→P2→…→Pn→P0。

## 3. 资源分配图（Resource-Allocation Graph）
• **用途**：通过有向图分析死锁是否存在。
• **组成**：
  • **进程节点（圆形）**：表示进程。
  • **资源节点（矩形）**：表示资源类型，圆点表示资源实例。
  • **边**：
    ◦ **请求边（Pi→Rj）**：进程Pi申请资源Rj。
    ◦ **分配边（Rj→Pi）**：资源Rj已分配给进程Pi。
• **死锁判断**：
  • 若无环，则无死锁。
  • 若有环且资源实例唯一，则存在死锁；若资源实例不唯一，可能无死锁。

## 4. 处理死锁的方法
1. **预防（Prevention）**：破坏死锁的必要条件。
2. **避免（Avoidance）**：动态检查资源分配状态（如银行家算法）。
3. **检测与恢复（Detection & Recovery）**：允许死锁发生，定期检测并解除。
4. **忽略（Ignorance）**：多数操作系统（如UNIX、Windows）采用此方法。

## 5. 死锁预防（破坏必要条件）
1. **破坏互斥**：允许资源共享（如只读文件），但对独占资源（如打印机）不可行。
2. **破坏占有并等待**：
   • **静态分配**：进程启动前申请所有所需资源（资源利用率低）。
   • **动态分配**：进程无资源时才可申请（可能导致饥饿）。
3. **破坏非抢占**：
   • 若进程申请资源失败，则释放已占用的资源（适用于易保存/恢复的资源，如CPU、内存）。
4. **破坏循环等待**：
   • **有序资源分配法**：为资源编号，进程必须按递增顺序申请资源（避免环路）。

## 6. 死锁避免（银行家算法）
• **核心思想**：动态检查资源分配是否会导致系统进入不安全状态（即无法找到安全序列）。
• **数据结构**：
  • **Available**：当前可用资源向量。
  • **Max**：每个进程的最大需求矩阵。
  • **Allocation**：已分配资源矩阵。
  • **Need**：进程还需资源矩阵（Need = Max - Allocation）。
• **安全性算法**：
  • 检查是否存在一个安全序列（所有进程能按顺序完成）。
• **资源请求算法**：
  1. 检查请求是否合法（Request ≤ Need）。
  2. 检查资源是否足够（Request ≤ Available）。
  3. 试分配并执行安全性算法，若安全则分配，否则拒绝。

## 7. 安全状态与不安全状态
• **安全状态**：存在至少一个安全序列，所有进程能顺利完成。
• **不安全状态**：可能进入死锁（但未必一定死锁）。
• **死锁状态必然是不安全状态**，但反之不成立。

## 8. 实际应用与局限性
• **银行家算法**：理论严谨，但需预先声明最大需求，且计算开销大，适合小型系统。
• **预防策略**：简单但限制严格，可能降低资源利用率。
• **检测与恢复**：适用于允许死锁偶尔发生的系统（如数据库）。

## 9. 关键结论
• 死锁是系统设计中的经典问题，需权衡性能与安全性。
• 多数现代操作系统选择忽略死锁，因预防和避免的开销较高，而死锁在实际中较少发生。
• 在关键系统中（如实时系统），需结合预防、避免或检测策略确保可靠性。