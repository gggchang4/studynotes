reference：Compilers principles
# chapter 1 编译程序概述

## 程序的翻译

程序的翻译通常有两种方式：**编译**方式和**解释**方式
### 编译方式
编译方式是一种分阶段进行的方式：翻译阶段->运行阶段

编译方式下的翻译程序
	编译程序：高级语言->低级语言（汇编语言或机器语言）
	汇编程序：汇编语言->机器语言

编译方式下，源程序的执行需要分阶段
	目标是机器语言程序，源程序执行分为两大阶段
		编译阶段和运行阶段
	目标程序是汇编语言程序，源程序的执行分为三个阶段
		编译阶段，汇编阶段，运行阶段

编译方式下，生成了目标代码，且可被多次使用

对编译程序而言，源程序是输入数据，目标程序是输出结果（输入输出都是字符串）
### 解释方式
完成解释工作的解释程序将按源程序中语句的动态顺序，逐句进行分析解释源程序，并立即执行
**本质区别**：解释方式不生成目标代码，直接执行源程序本身

#### 翻译的混合方式
兼有编译和解释过程
eg.Java
	在一台机器上编译得到字节码bytecode（中间程序）
	由虚拟机对字节码加以解释执行
		字节码可以在另一台机器上解释执行

## 编译程序的工作步骤

编译程序的工作步骤大体分为
	词法分析
	语法分析
	语义分析
	中间代码优化
	目标代码生成

### 词法分析

源程序由字符组成，词法分析依据词法规则，把源程序识别为一个个最小语法单位，并识别出与其相关的属性（数据类型等），并转换成*长度统一*的标准形式token

词法规则：EBNF（Extended Backus-Naur Form）
	<>括住待描述的语法成分
	::=表示语法成分的定义
	|表示或者
	[x] x可以出现零次或者一次
	{x} x可以出现零次到多次
	x(y|z) 等价于xy或xz
![[Pasted image 20250926144023.png|200]]
token：<token-name, attribute-value>

词法分析程序：scanner

---
### 语法分析

依据语法规则，逐一分析词法分析得到的单词，把单词串分解成各类语法单位

语法分析程序：parser

---
### 语义分析

依据语言的语义规则对语法分析得到的语法结构进行==静态==语义检查

凡在编译时可以确定的内容称为静态，凡必须推迟到程序运行时才能确定的内容称为动态的

语义分析程序：semantic analyzer

---
### 代码优化

依据程序的等价变换规则，尽量压缩目标程序运行所需的时间和所占的储存空间

目标代码优化程序：target code optimizer

---
### 代码生成

代码生成程序：code generator

---
### 表格管理

等级源程序中出现的每个名字以及名字的各种属性

符号表：symbol table

---
### 出错处理

源程序中的错误有语法错误和语义错误两种

---

## 编译程序的结构
编译的分析综合模型

![[Pasted image 20250926150052.png|400]]
### 分析部分
	词法分析 Lexical Analyses
	语法分析 Syntax Analyses
	语义分析 Semantic Analyses
### 综合阶段
	中间代码生成 Intermediate Generation
	代码优化 Intermediate Optimization
	代码生成 Code Generation

## 编译程序的组织形式
### 趟pass
一趟是指一个编译程序在编译时可把源程序或源程序的等价物（中间程序）从头到尾扫描一遍并转换成另一紧邻的等价物的全过程

分为单遍扫描的编译程序和多遍扫描的编译程序
![[Pasted image 20250926150449.png|300]]
![[Pasted image 20250926150513.png|300]]


### 编译的前端（front end）和后端（back end）
前端主要由于源语言有关但于目标机器无关的哪些部分组成
后端主要包括编译中与目标机器有关的那些部分
可通过改变编译程序的后端实现编译程序的移植

## 编译程序的构造

编译程序可以用机器语言，汇编语言和高级语言实现

高级语言的自编译性
编译的自展技术：
	通过一系列自展途径而形成编译程序的过程
		先构造语言的核心部分的编译程序（可低级语言实现）

# chapter 2 文法和语言的形式定义
语言的定义涉及三个方面
- 语法syntax
	由程序设计语言的基本符号组成程序中各个语法成分的一组规则
	词法规则
	语法规则
- 语义semantics
	各语法成分在运行阶段呗计算机执行时所做的工作及其结果
	静态语义：编译时刻可确定的语法成分含义
	动态语义：运行时刻才能确定的语法成分含义
- 语用
	表示语言符号及其使用者之间的关系
	涉及符号的来源，使用和影响
		如程序的设计风格

文法描述的是高级语言程序的构成规则
## 形式语言
定义：用一组数学符号和规则来描述语言的方式称为形式描述，把所用数学符号和规则称为形式语言

形式语言只是从语法上研究语言

最基本概念：符号串和符号串集合

## 字母表和符号串集合
### 字母表alphabet

元素有穷非空的集合，字母表的元素称为符号
eg.{a,b,c,....,y,z}，{0,1}等

常用大写字母A,B...表示字母表

符号不是字符，关键字等也属于符号

一个程序设计语言只使用有限符号集作为字母表

### 符号串与符号串集合

符号串是字母表中的符号所组成的任何有穷序列，通常用小写字母表示
不含任何符号的符号串称为空串，$\varepsilon$

- 符号串的长度：符号串中符号的个数，用$|x|$表示
	$|\varepsilon|=0$
- 符号串的连接
- 符号串的方幂
	x是一个符号串，把x自身连接n次得到的新的符号串，即z=xx...x（n个x），称为x的n次方幂，记作$x^n$
- 符号串集合：若集合中所有元素都是某字母表上的符号串，则称其为该字母表上的符号串集合，用大写英文字母表示
- 符号串集合的乘积
	符号串集合的乘积定义为：$AB = \{\, xy \mid x \in A,\, y \in B \,\}$
- 符号串集合的方幂
	![[Pasted image 20251010141957.png|200]]
- 符号串集合的闭包与正闭包
	- A的闭包$A^*$：A上所有有穷长度的符号串集合
		$A^{*} = \{\, \varepsilon \,\} \cup A \cup A^{2} \cup A^{3} \cup \dots$
	- A的正闭包$A^+$：
		$A^{+} = A^{*} - \{\, \varepsilon \,\} = A \cup A^{2} \cup A^{3} \cup \dots$

#### 串的各部分
- 串的前缀prefix
	从s尾部删除0或多个符号后得到的串
- 串的后缀suffix
	从s的开始处删除0个或多个符号后得到的串
- 串的子串substring
	删除s的某个前缀和后缀后得到的串
- 串的真前缀，真后缀，真子串
	s的既不等于ε，也不等于s本身的前缀、后缀和子串
- 串的子序列subsequence
	从s中删除0个或多个符号后得到的串，这些被删除的符号可能不相邻

形式语言是字母表上的符号串的任意集合

## 文法

### 终结符号terminal/词法单元token

终结符号是组成语言的基本符号，如保留字，运算符，界限符等。
终结符号是语言的不可再分的基本符号。
终结符号形成的集合记为$V_T$
### 非终结符号nonterminal/语法变量/语法成分

非终结符号用来表示语言的语法成分，如赋值语句
可以理解为生成规则的中间步骤
非终结符号形成的集合记为$V_N$

$V_T \cap V_N = \varnothing$

### 产生式production

产生式是一个对有序对$(\alpha,\beta)$，通常写作$\alpha\rightarrow\beta$或$\alpha::=\beta$
其中$\alpha$称为产生式的左部/头部，$\beta$称为产生式的右部/体
$\alpha \in (V_T \cup V_N)^+$, $\beta \in (V_T \cup V_N)^+$

产生式需要满足的条件
- α可以是$(V_T \cup V_N)^+$上的任意符号串，但必须至少包含一个非终结符，并且不能是空串
- β可以是$(V_T \cup V_N)^+$上的任意符号串，也可以是空串

产生式是用来定义一个语法成分的形成规则

### 文法

文法是产生式的有穷非空集合

文法的形式化描述
四元组$G[S]=(V_N,V_T,P,S)$
	$V_N$ -- 非终结符号集
	$V_T$ -- 终结符号集
	P -- 表示产生式的有穷非空集合
	S -- 开始符号，至少在一条产生式中作为左部

### 文法的分类
四种类型（乔姆斯基文法分类）
	0型：短语结构文法
	1型：上下文有关文法
	2型：上下文无关文法
	3型：正规（正则）文法
![[Pasted image 20251010144014.png|400]]
上下文无关文法可描述现今程序设计语言的绝大多数语法结构

文法的关系
![[Pasted image 20251010144147.png|200]]
## 语言的形式定义

语言是句子组成的集合，是字母表上的符号串的集合
语法成分的构成规则可以用文法予以描述
给定文法后，通过推导得到该文法所描述的语言
### 推导 derivation
#### 直接推导
如果$\alpha \rightarrow \beta$是文法G的一条产生式，而γ，δ是$(V_T \cup V_N)^*$中任意一个符号串，则将$\alpha \rightarrow \beta$作用于符号串$\gamma \alpha \delta$上得到符号串$\gamma \beta \delta$，称符号串$\gamma \alpha \delta$是符号串$\gamma \beta \delta$的直接推导，记作：
$\gamma \alpha \delta \Rightarrow \gamma \beta \delta$

#### 推导
设 $\alpha_0, \alpha_1, \ldots, \alpha_n \ (n > 0)$ 均为 $(V_T \cup V_N)^{*}$ 中的符号串，且有  
$\alpha_0 \Rightarrow \alpha_1 \Rightarrow \alpha_2 \Rightarrow \cdots \Rightarrow \alpha_{n-1} \Rightarrow \alpha_n$
则称以上序列是长度为 $n$ 的推导，即 $\alpha_0$ 可经过 $n$ 步推导得到 $\alpha_n$。  
$\alpha_0 \Rightarrow^{+} \alpha_n$  $\alpha_0 \Rightarrow^{*} \alpha_n$

推导的逆过程称为归约（reduction），即 $\alpha_n$ 可归约到 $\alpha_0$。
从开始符号出发推导的符号串才是有意义的

### 语言
1. 句型 sentential form
	设有文法 $( G[S] = (V_N, V_T, P, S)$，如果$S \Rightarrow^* u$，则称符号串u为文法$G[S]$的句型
	- 句型中可以包含非终结符号
	一棵语法树的末端节点从左向右构成的符号串
2. 句子sentence
	设有文法 $( G[S] = (V_N, V_T, P, S)$，如果$S \Rightarrow^* u$，且$u \in V_T^*$，则称符号串u为文法$G[S]$的句子
	- 句子中只能包含终结符号
	一棵语法树的末端节点从左向右构成的终结符号串
3. 文法G产生的语言
	设有文法 $( G[S] = (V_N, V_T, P, S)$，则文法$G[S]$描述的语言L为：
	$L(G[S])=\{\ u|S \Rightarrow^* u,且u \in V_T^* \}$
	- 语言是句子的集合，不包含中间句型
	由语法树生成的终结符号串的集合

### 为语言构造文法
从实际应用需要构造描述该语言的文法可以采用**凑规则**的方法进行
#### 凑规则方法
1. 找出语言的若干典型句子
2. 分析句子的构成特点
3. 根据句子的特点凑规则
4. 形成文法
5. 检查文法
	如果检查满足以下两点，则构造出的文法就是所求文法
	- 语言的所有句子都能由文法的开始符号推导得到
	- 文法开始符号推导出所有的终结符号串都是语言的句子

## 语法树 parse tree/syntax tree 
### 语法树定义
设有某语言的文法$G[S]=(V_N,V_T,P,S)$，满足以下条件的树称为一颗语法树
- 树中每个结点node都有标记label，该标记$\in V_N∪V_T$;
- 树根root的标记是开始/识别符号S
- 若某节点至少有一个后继，则其标记必为非终极符号
- 若一个标记为A的节点，它有标记依次为$X_1,X_2...X_n$的直接后继节点，则$A \rightarrow X_1X_2...X_n$必定为G的一条产生式。如果$A \rightarrow ε$ ，那么A只有标记为ε的子节点
### 语法树的构造
推导$\Rightarrow$语法树
1. 把开始符号（识别符号）作为根节点
2. 把每一个直接推导画一个分支
3. 重复2直到再无分枝可画时结束
![[Pasted image 20251013200335.png|100]]

语法树$\Rightarrow$推导
1. 依据分支建立直接推导，然后从语法树中减去这个分支
2. 重复1直到无枝可减

语法分析：为一个给定的终结符号串构建一颗语法分析树的过程
### 最左推导和最右推导 left/rightmost derivation
![[Pasted image 20251013203245.png|150]]
如果在某个推导过程中的任何一步直接推导$\alpha \Rightarrow \beta$中，都是对符号串的$\alpha$的最左（右）非终结符号进行替换，即为最左（右）推导。最右推导又叫做规范推导。由规范推导得到的句型称为规范句型
eg
G[E]：
	E→E + T | E - T | T
	T→$T^*$F | T /F | F
	F→ ( E ) | i
![[Pasted image 20251013203213.png]]

## 递归 recursive
如果文法的产生式呈$U \Rightarrow xUy (x,y \in (V_N∪V_T)^*)$形式，则称其为规则递归，也称直接递归
如果文法的产生式呈$U \Rightarrow^* xUy (x,y \in (V_N∪V_T)^*)$形式，则称其为文法递归，也称间接递归
- 如果文法的产生式呈$U \Rightarrow Uy (y \in (V_N∪V_T)^*)$形式，则称其为规则左递归，也称直接左递归
- 如果文法的产生式呈$U \Rightarrow^* Uy (y \in (V_N∪V_T)^*)$形式，则称其为文法左递归，也称间接左递归
- 如果文法的产生式呈$U \Rightarrow xU (x \in (V_N∪V_T)^*)$形式，则称其为规则右递归，也称直接右递归
- 如果文法的产生式呈$U \Rightarrow^* xU (x \in (V_N∪V_T)^*)$形式，则称其为文法右递归，也称间接右递归

文法使用递归定义的作用：用有穷表示无穷

## 等价文法
如果两个文法$G_1$$G_2$**产生的语言**是相同的，则称这两个文法是相同的，并且指的是$G_1,G_2$产生相同的符号串，不涉及符号串的语义
![[Pasted image 20251017141812.png|300]]
## 文法构造问题

例子：
```
E → E + T | T
T → T * F | F
F → (E) | i
```
### 运算符结合顺序问题
左右结合在文法中的体现为左右递归
![[Pasted image 20251017143527.png|300]]

### 运算符优先级问题
在上下文无关文法中，经常通过分层定义产生式来体现不同优先级，以上面文法为例
优先级高的运算符比优先级低的运算符
	晚推导得到
	处于语法树中更底层
![[Pasted image 20251017143411.png|300]]

## 文法的实用限制
在实际对文法的使用中可能对文法有一些限制
- 不能有二义性
- 不能有左递归
- 不能有空串
### 二义性 ambiguous grammar
如果文法G的某个句子存在两颗或以上不同的语法树（即有两个不同的最左/最右推导），称该文法是二义性文法
![[Pasted image 20251017143906.png|400]]
解决方法
	在语义上加以限制
	**重新构造一个等价的无二义性的文法

#### 如何构造等价的无二义性文法？
1. 优先级不明确和结合顺序不明确的二义性
核心目标：通过引入不同优先级层次的非终结符和递归方向控制结合性

2. if-else语句的无二义性构造
核心：区分匹配语句和非匹配语句
![[Pasted image 20251017144732.png|400]]
###  文法压缩
- 文法不能含有有害产生式
- 文法不能含有多余产生式
	- 不可达非终结符号
		从开始符号出发的所有推导都不可能用到该非终结符号
	- 无法推导出的终结符号串

如何压缩
- 正向标记法 -> 不可达非终结符号
- 反向标记法 -> 无法推导出终结符号串
![[Pasted image 20251017150101.png|400]]

### 空规则递归
### 左递归

# chapter 3 词法分析 Part1 有穷自动机

# chapter 3 词法分析 Part2 词法分析程序实现

# chapter 4 语法分析 Syntax Analysis

## 自上而下语法分析
基本思想：
- 推导：从开始符号出发不断建立直接推导，试图构造一个最左推到序列，最终由它推导出与输入符号串相同的符号串
- 语法树：以开始/识别符号为树的根结点，试图向下构造一棵语法树，其末端结点符号串与输入符号串相同
- 程序翻译：以开始/识别符号为树的根结点，试图向下构造一棵语法树，其末端结点符号串与输入符号串相同
![[Pasted image 20251017160506.png|300]]
自上而下遇到的问题：
如果文法中存在以下产生式
$U \rightarrow \alpha_1|\alpha_2|...|\alpha_n$
在自上而下过程中需要对U展开，不知道该按哪一项展开
回溯backtracking：分析匹配失败后，必须退回到出错点，选择其他可能的产生式重新推导
当文法中出现左递归（存在非终结符号U，对于它有 U→U…或 U$\Rightarrow^*$ U…）时，会使分析过程陷入无限循环
![[Pasted image 20251017162151.png|200]]
### 左递归的消除
左递归在文法中的作用：产生无限个符号串

#### 直接左递归的消除
1. 采用EBNF表示
2. 引入新的非终结符号，将左递归改写为右递归
![[Pasted image 20251017164205.png|400]]
#### 间接左递归的消除
















